[{"apiChange":{"library":"spring-framework","name":"org.springframework.web.bind.EscapedErrors#getFieldErrorCount()","from_version":"v5.3.34","to_version":"v6.0.19","type":"method","signature":"public int getFieldErrorCount()","documentation":null,"changetype":"stabilized","source_code":"\tpublic int getFieldErrorCount() {\n\t\treturn this.source.getFieldErrorCount();\n\t}","query":"Design a controller method in a Spring MVC application that processes form submissions and returns the total number of fields that failed validation, ensuring the response accurately reflects the validation state.","function_signature":"public int getFieldErrorCount(EscapedErrors escapedErrors)","test_program":"import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.springframework.validation.BindException;\nimport org.springframework.validation.FieldError;\n\npublic class ExampleSpringServiceTest {\n    private ExampleSpringService service = new ExampleSpringService();\n\n    @Test\n    public void testGetFieldErrorCount_NoErrors() {\n        BindException errors = new BindException(new Object(), \"objectName\");\n        int count = service.getFieldErrorCount(errors);\n        assertEquals(0, count);\n    }\n\n    @Test\n    public void testGetFieldErrorCount_SomeErrors() {\n        BindException errors = new BindException(new Object(), \"objectName\");\n        errors.addError(new FieldError(\"objectName\", \"field1\", \"error1\"));\n        errors.addError(new FieldError(\"objectName\", \"field2\", \"error2\"));\n        int count = service.getFieldErrorCount(errors);\n        assertEquals(2, count);\n    }\n\n    @Test\n    public void testGetFieldErrorCount_AllFieldsHaveErrors() {\n        BindException errors = new BindException(new Object(), \"objectName\");\n        errors.addError(new FieldError(\"objectName\", \"field1\", \"error1\"));\n        errors.addError(new FieldError(\"objectName\", \"field2\", \"error2\"));\n        errors.addError(new FieldError(\"objectName\", \"field3\", \"error3\"));\n        errors.addError(new FieldError(\"objectName\", \"field4\", \"error4\"));\n        errors.addError(new FieldError(\"objectName\", \"field5\", \"error5\"));\n        int count = service.getFieldErrorCount(errors);\n        assertEquals(5, count);\n    }\n}\n"},"generatedCode":"import org.springframework.validation.Errors;\nimport org.springframework.web.bind.EscapedErrors;\n\npublic class ExampleSpringService {\n    /**\n     * Primary API that the controller can call directly with an {@link EscapedErrors}\n     * instance. It simply delegates to the framework's getFieldErrorCount().\n     */\n    public int getFieldErrorCount(EscapedErrors escapedErrors) {\n        return escapedErrors != null ? escapedErrors.getFieldErrorCount() : 0;\n    }\n\n    /**\n     * Convenience overload that accepts any {@link Errors} implementation (e.g. the\n     * {@link org.springframework.validation.BindException} used in the tests). We wrap it in\n     * {@link EscapedErrors} so downstream code is consistently protected against XSS.\n     */\n    public int getFieldErrorCount(Errors errors) {\n        if (errors == null) {\n            return 0;\n        }\n        return getFieldErrorCount(errors instanceof EscapedErrors ? (EscapedErrors) errors : new EscapedErrors(errors));\n    }\n}\n","gradleBuild":"plugins {\n    id 'java'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    // Validation & core context support (contains BindException, FieldError, etc.)\n    implementation 'org.springframework:spring-context:6.0.19'\n    // EscapedErrors lives in spring-web\n    implementation 'org.springframework:spring-web:6.0.19'\n\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'\n}\n\ntest {\n    useJUnitPlatform()\n}\n","model":"O3","success":true,"errorOutput":"No error output"}]